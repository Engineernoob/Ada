"""Tool registry with available actions and operations for Ada's planning system."""

from __future__ import annotations

import json
import os
import subprocess
import time
from typing import Any, Dict, List, Optional
from pathlib import Path


class ToolResult:
    """Result from tool execution."""

    def __init__(self, success: bool, data: Any = None, error: Optional[str] = None):
        self.success = success
        self.data = data
        self.error = error
        self.timestamp = time.time()

    def to_dict(self) -> dict:
        """Convert to dictionary representation."""
        return {
            "success": self.success,
            "data": self.data,
            "error": self.error,
            "timestamp": self.timestamp,
        }


class ToolRegistry:
    """Registry of available tools and their capabilities."""

    def __init__(self) -> None:
        self.tools = self._register_tools()
        self.base_path = Path.cwd()
        self.storage_path = Path("storage")
        self.storage_path.mkdir(exist_ok=True)

        # Initialize journal for notes
        self.journal_path = self.storage_path / "journal.json"
        if not self.journal_path.exists():
            with open(self.journal_path, "w") as f:
                json.dump([], f)

    def _register_tools(self) -> Dict[str, callable]:
        """Register all available tools."""
        return {
            "file_ops": self._file_operations,
            "web_search": self._web_search,
            "summarize": self._summarize_text,
            "note": self._note_operations,
            "analyze": self._analyze_data,
        }

    def execute(self, tool_name: str, action: str, **kwargs) -> ToolResult:
        """
        Execute a tool action.

        Args:
            tool_name: Name of the tool to execute
            action: Action to perform
            **kwargs: Parameters for the action

        Returns:
            Result of the tool execution
        """
        if tool_name not in self.tools:
            return ToolResult(False, error=f"Unknown tool: {tool_name}")

        try:
            return self.tools[tool_name](action, **kwargs)
        except Exception as e:
            return ToolResult(False, error=f"Tool execution failed: {str(e)}")

    def _file_operations(self, action: str, **kwargs) -> ToolResult:
        """File system operations."""
        try:
            if action == "read":
                path = kwargs.get("path", "")
                if not path:
                    return ToolResult(
                        False, error="No path provided for read operation"
                    )

                file_path = self.base_path / path
                if not file_path.exists():
                    return ToolResult(False, error=f"File not found: {path}")

                with open(file_path, "r", encoding="utf-8") as f:
                    content = f.read()

                return ToolResult(True, data=content)

            elif action == "write":
                path = kwargs.get("path", "")
                content = kwargs.get("content", "") or kwargs.get("data", "")
                description = kwargs.get("description", "")

                if not path:
                    return ToolResult(
                        False, error="No path provided for write operation"
                    )

                file_path = self.base_path / path
                file_path.parent.mkdir(parents=True, exist_ok=True)

                # Add metadata if empty content
                if not content and description:
                    content = f"# {description}\n\n# Generated by Ada\n"

                with open(file_path, "w", encoding="utf-8") as f:
                    f.write(content)

                return ToolResult(True, data=f"Successfully wrote to {path}")

            elif action == "list":
                path = kwargs.get("path", ".")
                dir_path = self.base_path / path

                if not dir_path.exists():
                    return ToolResult(False, error=f"Directory not found: {path}")

                items = []
                for item in dir_path.iterdir():
                    item_info = {
                        "name": item.name,
                        "type": "directory" if item.is_dir() else "file",
                    }
                    items.append(item_info)

                return ToolResult(True, data=items)

            elif action == "copy":
                source = kwargs.get("source", "")
                dest = kwargs.get("destination", "")

                if not source or not dest:
                    return ToolResult(
                        False,
                        error="Source and destination required for copy operation",
                    )

                source_path = self.base_path / source
                dest_path = self.base_path / dest

                import shutil

                shutil.copy2(source_path, dest_path)

                return ToolResult(True, data=f"Successfully copied {source} to {dest}")

            elif action == "move":
                source = kwargs.get("source", "")
                dest = kwargs.get("destination", "")

                if not source or not dest:
                    return ToolResult(
                        False,
                        error="Source and destination required for move operation",
                    )

                source_path = self.base_path / source
                dest_path = self.base_path / dest

                import shutil

                shutil.move(source_path, dest_path)

                return ToolResult(True, data=f"Successfully moved {source} to {dest}")

            elif action == "reorganize":
                # Simplified reorganization -alist items and create organized structure
                path = kwargs.get("source", ".")
                plan = kwargs.get("plan", "")

                dir_path = self.base_path / path
                organized_path = dir_path / "organized"
                organized_path.mkdir(exist_ok=True)

                # Simple organization by file type
                file_types = {
                    "texts": [".txt", ".md", ".json"],
                    "code": [".py", ".js", ".html", ".css"],
                    "data": [".csv", ".json", ".db"],
                }

                organized_items = []
                for item in dir_path.iterdir():
                    if item.is_file():
                        # Try to categorize by extension
                        for category, extensions in file_types.items():
                            if item.suffix.lower() in extensions:
                                category_dir = organized_path / category
                                category_dir.mkdir(exist_ok=True)
                                dest_path = category_dir / item.name
                                dest_path.write_bytes(item.read_bytes())
                                organized_items.append(str(dest_path))
                                break

                return ToolResult(True, data=f"Organized {len(organized_items)} files")

            else:
                return ToolResult(False, error=f"Unknown file operation: {action}")

        except Exception as e:
            return ToolResult(False, error=f"File operation failed: {str(e)}")

    def _web_search(self, action: str, **kwargs) -> ToolResult:
        """Web search operations."""
        try:
            if action == "search":
                query = kwargs.get("query", "")
                if not query:
                    return ToolResult(False, error="No query provided for search")

                # Use system search as fallback (mdfind on macOS)
                try:
                    result = subprocess.run(
                        ["mdfind", "-name", f"*{query}*"],
                        capture_output=True,
                        text=True,
                        timeout=10,
                    )

                    if result.returncode == 0:
                        search_results = result.stdout.strip().split("\n")
                        search_results = [r for r in search_results if r]

                        # Limit results
                        search_results = search_results[:10]

                        return ToolResult(
                            True,
                            data={
                                "query": query,
                                "results": search_results,
                                "count": len(search_results),
                            },
                        )
                    else:
                        return ToolResult(
                            True,
                            data={
                                "query": query,
                                "results": [],
                                "message": "No local search results found",
                            },
                        )

                except (subprocess.TimeoutExpired, FileNotFoundError):
                    # Fallback to simulated search
                    simulated_results = [
                        f"/documents/{query}_research.pdf",
                        f"/notes/{query}_thoughts.md",
                        f"/projects/{query}_analysis.txt",
                    ]

                    return ToolResult(
                        True,
                        data={
                            "query": query,
                            "results": simulated_results,
                            "count": len(simulated_results),
                            "message": "Simulated search results (local search unavailable)",
                        },
                    )

            elif action == "discover":
                # Find related files based on content similarity
                topic = kwargs.get("topic", "")
                if not topic:
                    return ToolResult(False, error="No topic provided for discovery")

                # Simple discovery based on file names
                relevant_files = []
                for root, dirs, files in os.walk(self.base_path):
                    for file in files:
                        if topic.lower() in file.lower():
                            relevant_files.append(str(Path(root) / file))

                return ToolResult(
                    True,
                    data={
                        "topic": topic,
                        "files": relevant_files[:10],
                        "count": len(relevant_files),
                    },
                )

            elif action == "find":
                target = kwargs.get("target", "")
                if not target:
                    return ToolResult(False, error="No target provided for find")

                # Find files/directories by name
                found_items = []
                for root, dirs, files in os.walk(self.base_path):
                    for item in files + dirs:
                        if target.lower() in item.lower():
                            found_items.append(str(Path(root) / item))

                return ToolResult(
                    True,
                    data={
                        "target": target,
                        "items": found_items[:20],
                        "count": len(found_items),
                    },
                )

            else:
                return ToolResult(
                    False, error=f"Unknown web search operation: {action}"
                )

        except Exception as e:
            return ToolResult(False, error=f"Web search operation failed: {str(e)}")

    def _summarize_text(self, action: str, **kwargs) -> ToolResult:
        """Text summarization operations."""
        try:
            if action == "run":
                text_input = kwargs.get("input", "") or kwargs.get("text", "")
                max_length = kwargs.get("max_length", 200)

                if not text_input:
                    return ToolResult(
                        False, error="No input text provided for summarization"
                    )

                # Simple extractive summarization
                sentences = text_input.split(". ")
                sentences = [s.strip() for s in sentences if s.strip()]

                if len(sentences) <= 3:
                    summary = ". ".join(sentences)
                else:
                    # Take first, middle, and last sentences as a simple summary
                    middle_idx = len(sentences) // 2
                    summary_sentences = [
                        sentences[0],
                        sentences[middle_idx],
                        sentences[-1],
                    ]
                    summary = ". ".join(summary_sentences)

                # Truncate if too long
                if len(summary) > max_length:
                    summary = summary[: max_length - 3] + "..."

                return ToolResult(True, data=summary)

            elif action == "extract":
                text_input = kwargs.get("input", "") or kwargs.get("text", "")
                keywords = kwargs.get("keywords", [])

                if not text_input:
                    return ToolResult(
                        False, error="No input text provided for extraction"
                    )

                # Simple keyword extraction
                words = text_input.lower().split()

                # Extract sentences containing keywords or important patterns
                sentences = text_input.split(". ")
                important_sentences = []

                for sentence in sentences:
                    sentence_lower = sentence.lower()

                    # Check for keywords or important patterns
                    if any(keyword.lower() in sentence_lower for keyword in keywords):
                        important_sentences.append(sentence.strip())
                    elif any(
                        pattern in sentence_lower
                        for pattern in [
                            "important",
                            "key",
                            "main",
                            "primary",
                            "critical",
                            "essential",
                        ]
                    ):
                        important_sentences.append(sentence.strip())

                # Add some sentences back if we get too few
                if len(important_sentences) < 3:
                    remaining = [
                        s.strip()
                        for s in sentences
                        if s.strip() and s.strip() not in important_sentences
                    ]
                    important_sentences.extend(
                        remaining[: 3 - len(important_sentences)]
                    )

                extracted_text = ". ".join(important_sentences[:5])

                return ToolResult(True, data=extracted_text)

            elif action == "condense":
                text_input = kwargs.get("input", "") or kwargs.get("text", "")
                target_length = kwargs.get("target_length", 100)

                if not text_input:
                    return ToolResult(
                        False, error="No input text provided for condensation"
                    )

                # Simple truncation condensation
                words = text_input.split()
                if len(words) <= target_length // 4:
                    condensed = text_input
                else:
                    condensed = " ".join(words[: target_length // 4]) + "..."

                return ToolResult(True, data=condensed)

            else:
                return ToolResult(False, error=f"Unknown summarize operation: {action}")

        except Exception as e:
            return ToolResult(False, error=f"Summarization operation failed: {str(e)}")

    def _note_operations(self, action: str, **kwargs) -> ToolResult:
        """Note and journal operations."""
        try:
            if action == "write":
                text = kwargs.get("text", "") or kwargs.get("content", "")
                category = kwargs.get("category", "general")

                if not text:
                    return ToolResult(False, error="No text provided for note")

                # Load existing journal
                with open(self.journal_path, "r") as f:
                    journal = json.load(f)

                # Create new note entry
                note = {
                    "id": len(journal) + 1,
                    "text": text,
                    "category": category,
                    "timestamp": time.time(),
                    "date": time.strftime("%Y-%m-%d %H:%M:%S"),
                }

                journal.append(note)

                # Save journal
                with open(self.journal_path, "w") as f:
                    json.dump(journal, f, indent=2)

                return ToolResult(True, data=f"Note saved with ID {note['id']}")

            elif action == "append":
                text = kwargs.get("text", "")
                note_id = kwargs.get(
                    "id", ""
                )  # If ID provided, append to existing note

                if not text:
                    return ToolResult(False, error="No text provided for note append")

                # Load existing journal
                with open(self.journal_path, "r") as f:
                    journal = json.load(f)

                if note_id:
                    # Append to existing note
                    for note in journal:
                        if str(note["id"]) == str(note_id):
                            note["text"] += f"\n\n{text}"
                            break
                else:
                    # Create new note
                    note = {
                        "id": len(journal) + 1,
                        "text": text,
                        "category": "appended",
                        "timestamp": time.time(),
                        "date": time.strftime("%Y-%m-%d %H:%M:%S"),
                    }
                    journal.append(note)

                # Save journal
                with open(self.journal_path, "w") as f:
                    json.dump(journal, f, indent=2)

                return ToolResult(True, data="Note appended successfully")

            elif action == "organize":
                # Group notes by category
                with open(self.journal_path, "r") as f:
                    journal = json.load(f)

                categories = {}
                for note in journal:
                    cat = note.get("category", "general")
                    if cat not in categories:
                        categories[cat] = []
                    categories[cat].append(note)

                # Create organized summary
                organized_summary = "# Journal Organization\n\n"
                for category, notes in categories.items():
                    organized_summary += (
                        f"## {category.title()} ({len(notes)} notes)\n\n"
                    )
                    for note in notes[-5:]:  # Show last 5 notes per category
                        organized_summary += (
                            f"- {note['date']}: {note['text'][:100]}...\n"
                        )
                    organized_summary += "\n"

                # Save organized summary
                summary_path = self.storage_path / "journal_organization.md"
                with open(summary_path, "w") as f:
                    f.write(organized_summary)

                return ToolResult(
                    True, data=f"Organized journal into {len(categories)} categories"
                )

            else:
                return ToolResult(False, error=f"Unknown note operation: {action}")

        except Exception as e:
            return ToolResult(False, error=f"Note operation failed: {str(e)}")

    def _analyze_data(self, action: str, **kwargs) -> ToolResult:
        """Data analysis operations."""
        try:
            if action == "evaluate":
                data = (
                    kwargs.get("input", "")
                    or kwargs.get("data", "")
                    or kwargs.get("topic", "")
                )

                if not data:
                    return ToolResult(False, error="No data provided for evaluation")

                # Simple evaluation based on content analysis
                evaluation = {
                    "length": len(str(data)),
                    "type": "text" if isinstance(data, str) else "unknown",
                    "complexity": (
                        "simple"
                        if len(str(data)) < 100
                        else "medium" if len(str(data)) < 500 else "complex"
                    ),
                    "keywords": self._extract_keywords(str(data)),
                    "sentiment": self._analyze_sentiment(str(data)),
                }

                return ToolResult(True, data=evaluation)

            elif action == "interpret":
                data = kwargs.get("input", "") or kwargs.get("data", "")

                if not data:
                    return ToolResult(
                        False, error="No data provided for interpretation"
                    )

                # Simple interpretation
                interpretation = "Analysis of provided content:\n"
                interpretation += f"- Content length: {len(str(data))} characters\n"
                interpretation += f"- Contains {len(self._extract_keywords(str(data)))} unique keywords\n"
                interpretation += "- Estimated complexity: " + (
                    "simple"
                    if len(str(data)) < 100
                    else "medium" if len(str(data)) < 500 else "complex"
                )

                return ToolResult(True, data=interpretation)

            else:
                return ToolResult(False, error=f"Unknown analysis operation: {action}")

        except Exception as e:
            return ToolResult(False, error=f"Analysis operation failed: {str(e)}")

    def _extract_keywords(self, text: str) -> List[str]:
        """Extract simple keywords from text."""
        # Remove common stop words and get unique words
        stop_words = {
            "the",
            "a",
            "an",
            "and",
            "or",
            "but",
            "in",
            "on",
            "at",
            "to",
            "for",
            "of",
            "with",
            "by",
            "is",
            "are",
            "was",
            "were",
            "be",
            "been",
            "have",
            "has",
            "had",
            "do",
            "does",
            "did",
            "will",
            "would",
            "could",
            "should",
            "can",
            "may",
            "might",
            "this",
            "that",
            "these",
            "those",
            "i",
            "you",
            "he",
            "she",
            "it",
            "we",
            "they",
        }

        words = (
            text.lower()
            .replace(".", "")
            .replace(",", "")
            .replace("!", "")
            .replace("?", "")
            .split()
        )
        keywords = [word for word in words if word not in stop_words and len(word) > 3]

        return list(set(keywords))[:10]  # Return top 10 unique keywords

    def _analyze_sentiment(self, text: str) -> str:
        """Simple sentiment analysis."""
        positive_words = {
            "good",
            "great",
            "excellent",
            "positive",
            "wonderful",
            "fantastic",
            "amazing",
            "love",
            "like",
            "best",
            "happy",
            "joy",
            "success",
            "beautiful",
        }
        negative_words = {
            "bad",
            "terrible",
            "awful",
            "negative",
            "horrible",
            "worst",
            "hate",
            "dislike",
            "sad",
            "angry",
            "fail",
            "failure",
            "ugly",
        }

        words = text.lower().split()
        positive_count = sum(1 for word in words if word in positive_words)
        negative_count = sum(1 for word in words if word in negative_words)

        if positive_count > negative_count:
            return "positive"
        elif negative_count > positive_count:
            return "negative"
        else:
            return "neutral"

    def get_tool_info(self) -> dict:
        """Get information about available tools."""
        tool_info = {}

        for tool_name in self.tools.keys():
            tool_info[tool_name] = {
                "name": tool_name,
                "actions": list(self._get_tool_actions(tool_name)),
                "description": self._get_tool_description(tool_name),
            }

        return tool_info

    def _get_tool_actions(self, tool_name: str) -> List[str]:
        """Get available actions for a tool."""
        actions = {
            "file_ops": ["read", "write", "list", "copy", "move", "reorganize"],
            "web_search": ["search", "discover", "find"],
            "summarize": ["run", "extract", "condense"],
            "note": ["write", "append", "organize"],
            "analyze": ["evaluate", "interpret"],
        }
        return actions.get(tool_name, [])

    def _get_tool_description(self, tool_name: str) -> str:
        """Get description for a tool."""
        descriptions = {
            "file_ops": "File system operations (read, write, list, copy, move)",
            "web_search": "Web and local search capabilities",
            "summarize": "Text summarization and content extraction",
            "note": "Note-taking and journal operations",
            "analyze": "Data analysis and interpretation",
        }
        return descriptions.get(tool_name, "No description available")


# Global tool registry instance
tool_registry = ToolRegistry()
